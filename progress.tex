\section{Research Progress and Plan}\label{sec:progress}
This section describes the progress of our research and the plan towards achieving the objectives outlined in Section \ref{sec:objectives}.

\subsection{Transitions and Continuity of \acrshort{ucsp} Phases}\label{sec:dynamic_dfas}
As discussed in Section \ref{sec:transitions}, the state model of \acrshort{ucsp} is restrictive and cannot fit all use-cases.
For this reason, \acrshort{ucsp} must be extended to support multiple state models such that it dynamically selects the suitable model.
A state model for \gls{ucon} can be represented as a \gls{dfa} as follows:
\[M = (Q,\Sigma,\delta,q_0,F)\]
where:
\begin{itemize}
	\item \(Q\) is the set of phases: \[Q := \{init, pre, ongoing, post, finish\}\]
	\item $\Sigma$ is the set of inputs of the \gls{dfa}. Transitions depend on the evaluation decision, so the inputs are: \[\Sigma := \{deny, permit, indeterminate, inapplicable, request, end\}\]
	\item \(\delta\) is the transition function: \[\delta:Q\times\Sigma \rightarrow Q\]
	\item \(q_0\) is the initial state: \[q_0 := init\]
	\item and \(F\) is the set of exit states.
\end{itemize}
\smallskip

The only element that differentiates \gls{ucon} state models from each other is the transition function \(\delta\).
Accordingly, we outline the following possible \gls{ucon} state transitions for each phase depending on the evaluation decision:
\begin{itemize}
	\item transitions at the \(pre\) phase:
	\begin{itemize}
		\item \(inapplicable\) decision: This means that there are no policies that match the request. Re-evaluations will lead to the same decision in this case (unless the administrator installs a new policy that matches the request). Thus, the usage session must be terminated.
		\item \(permit\) decision: Implies that access has been granted and usage will start right after, so the session must move to the \(ongoing\) phase in this case.
		\item \(indterminate\): Must trigger one of the following two transitions:
		\begin{itemize}
			\item A transition to the exit state terminating the session; or
			\item A local transition to the \(pre\) phase allowing attribute updates or user behaviour changes to trigger re-revaluations. 
		\end{itemize}
		\item \(deny\) decision: Must trigger one of the following two transitions:
		\begin{itemize}
			\item A transition to the exit state terminating the session; or
			\item A local transition to the \(pre\) state allowing attribute updates or user behaviour changes to trigger re-revaluations. 
		\end{itemize}
	\end{itemize}
	\item transitions at the \(ongoing\) phase:
	\begin{itemize}
		\item \(inapplicable\) decision: This SHOULD NOT be possible in the \(ongoing\) phase. This is because \(ongoing\) implies that a policy has already been found and usage has started. However, if for some reason (e.g., system error), all matching policies were removed, and the re-evaluation resulted in \(inapplicable\), then the session must be terminated. 
		\item \(permit\) decision: Must keep the session in the \(ongoing\) phase.
		\item \(indterminate\) decision: Must trigger one of the following two transitions:
		\begin{itemize}
			\item A transition to the \(post\) phase thus ending the usage; or
			\item A local transition to the \(ongoing\) phase allowing the session to be re-evaluated when an attribute is updated or when user behaviour changes. 
		\end{itemize}
		\item \(deny\) decision: Implies that access has been revoked, so this must always trigger a transition to the \(post\) phase.
	\end{itemize}
	\item transitions at the \(post\) phase: Any decision in the \(post\) phase must trigger one of the following two transitions:
	\begin{itemize}
		\item A transition to the exit state thus terminating the session, which means \(post\) rules are evaluated only once; or
		\item A local transition to the \(post\) phase allowing multiple re-evaluations and consequently multiple \(post\) rules to be evaluated and enforced.
	\end{itemize}
\end{itemize}
In all phases, the session can be terminated with the \textit{end access} action performed by the subject or the \gls{pep}.

The combinations of the above transitions result in 32 different transition functions and consequently in 32 different \gls{ucon} \glspl{dfa}.
\acrshort{ucsp} must enable these \glspl{dfa} in order to support different use-cases.
The same \acrshort{ucsp} node may handle different use-cases that require different state models, thus the state model must be selected per usage session rather than per \acrshort{ucsp} node.
As aforementioned, \acrshort{ucsp} uses \gls{alfa} policy language which conforms to a hierarchy of policy sets, policies and rules where combining algorithms are used to resolve conflicts when multiple policy sets, policies or rules are applicable.
However, top-level policy sets (i.e., not nested under any other policy sets) are not selected or combined by combining algorithms.
Instead, \acrshort{ucsp} assumes that top-level policy sets are mutually exclusive, so for each usage request, one and only one top-level policy set is selected and associated with the corresponding usage session.
%This means that only policy sets and policies that are nested under the selected top-level policy set will be evaluated throughout the lifecycle of the usage session.
%One approach to enable selecting state models per usage sessions is to define state transitions in policies. 
%However, such approach allows usage sessions to change their state models while they are in progress because different policies may be re-evaluated depending on attribute updates and each policy may be associated with a different state model.
%In addition, if the state models are conflicting, then a selection mechanism would be needed in order to resolve conflicts.
%Allowing usage sessions may be appropriate for some use-cases, but it requires further analysis and careful study.
Accordingly, to allow state models to be selected per usage sessions, we propose associating \glspl{dfa} with top-level policy sets.
We also propose the use of a policy language or a rule-based system in order to decide how to transition between phases based on the current phase and on the evaluation decision.
Therefore, when an attribute value changes and policies are re-evaluated, \acrshort{ucsp} also checks the transition rules and changes the phase accordingly.

One way to express transitions between phases is using \gls{alfa} policy language such that the current phase and the evaluation decision are considered attributes, and the transition to the next phases is defined as an obligation.
An example transitions policy is shown in Listing \ref{lst:transitions}.
In this example, the target clause of the policy defines that the policy is applicable when the session is in the \(pre\) phase.
The target clause of first rule states that the rule must be selected if the evaluation decision is \(permit\), and the obligation states that the phase must be updated to \(ongoing\).
Similarly, the second rule specifies that the session must move to the end state (i.e., terminated) if the evaluation decision is \(inapplicable\).
In both cases, the \texttt{permit} effect is not considered because this policy is not used for access control decision, but rather to decide how to transition among \gls{ucon} phases.

Since \gls{alfa} is an access control policy language, it may not be the best language for defining transitions, so we plan to explore Drools \cite{drools}, a rule engine that enables users to define actions to be defined based on conditions.
\gls{alfa} may have an advantage over \gls{drl} because \acrshort{ucsp} already incorporates an \gls{alfa} policy engine so no extra implementation is required.
Nevertheless, we will soon provide a comparison between the two languages and use one of them as language for defining and selecting state models, which will be the next and final step of this part of our research.

\begin{lstlisting}[float=!tbh, caption={An example of defining phase transitions in ALFA},label={lst:transitions}]
	policy pre-transitions {
		target clause Attributes.ucs.phase == ''pre''
		apply firstApplicable
		rule permit {
			target clause Attributes.ucs.decision == ''permit''
			permit
			on permit {
				obligation to-ongoing {
					Attributes.ucs.phase = ''ongoing''
				}
			}
		}
		rule inapplicable {
			target clause Attributes.ucs.decision == ''inapplicable''
			permit
			on permit {
				obligation to-end {
					Attributes.ucs.phase = ''end''
				}
			}
		}
	};
\end{lstlisting}

Using policies or rules to define how to transition between \gls{ucon} phases allows an easy addition of other phases such as \(suspended\).
This is because new phases can be easily expressed in the selected policy/rule language.
In addition, \gls{alfa} rules can be easily classified with the new phases by adding a check on the phase attribute in the target clauses of rules.
The implementation of this solution is currently in progress and will be completed soon once the policy/rule language of expressing state transitions is decided.

\subsection{Generalised Session-Based \gls{abac} Model}\label{sec:sbsabac}
We noted in previous sections that the three \gls{ucon} phases (i.e., \(pre\), \(ongoing\) and \(post\)) cannot accommodate complex use-cases as different use-cases require different classifications.
We also showed that continuous monitoring and re-evaluations do not necessarily have to be restricted to the \(ongoing\) phase.
Moreover, the original \gls{ucon} model distinguishes between mutable and immutable attributes and assumes that immutable attributes do not change during usage sessions because they require administrative actions in order to be updated.
We argue that such administrative actions can occur while a usage session is in progress, and consequently all attributes must be considered mutable.
For this reason, we propose a generalisation of the \gls{ucon} model such that authorisation sessions can be classified into any number of user-defined phases, and all phases are continuous.
This section provides a definition of the state of an authorisation session in the generalised model, and discusses the classification of states into phases.

When a request is created, a set of decision predicates that match the request is selected for evaluation.
Since decision predicates are formed over attributes, we define the state of an authorisation session as an assignment of values to all attributes required for the evaluation of decision predicates.
Let \(A\) be the set of attributes that are required for the evaluation of decision predicates, and let \(V\) be the set of all possible values corresponding to the required attributes.
Accordingly, we define the state of an authorisation session as a partial mapping from \(A\) to \(V\) as follows: \[s: A \rightharpoonup V\]
Based on this definition, the state of an authorisation changes whenever an attribute value is updated.
Thus, an authorisation session transitions among a set of states where each state is different than the others by at least one attribute value.
The model must allow the classification of authorisation states into user-defined phases.
Let \(S\) be the set of all possible authorisation states, and let \(P\) be the set of all phases defined by the user for a specific use-case.
We define the phase of the authorisation as a surjective non-injective mapping from \(S\) to \(P\) as follows: \[\rho: S \rightarrow P\]
such that: \[\forall p \in P \quad \exists \: s \in S \quad \textnormal{such that}\quad \rho(s) = p\]
In \gls{ucon}, the mapping from states to phases depends on the evaluation of policies and the corresponding decision.
Therefore, \gls{ucon} can be realised with our generalised model such that mapping function \(\rho\) from states to phases is the same evaluation function of decision predicates.
For other use-cases such as data flow control, the mapping into phases does not necessarily depend on the evaluation of decision predicates, and thus the mapping function \(\rho\) is determined by external factors (e.g., flow of data).
This part of our research is still a work in progress, and we plan to study and verify the formalism of the model in the next steps.
Furthermore, the model can be generalised further into a continuous policy-based decision making model that goes beyond access control where the decision space is wider than permitting or denying access.
However, this is a longer term goal that is out of the scope of the current work.

\subsection{Policy-Based Identity and Privilege Management}\label{sec:siuv}
As mentioned in Section \ref{sec:architectural}, one of our architectural objectives is to adopt the principles of \gls{ucon} in identity and privilege management applications.
In \cite{siuv}, we introduced \acrshort{siuv}\footnote{\gls{siuv}}: a vehicular \gls{iam} system that supports dynamic and stateful identity and privilege management, context-aware and continuous usage control, as well as the \gls{polp}.
\gls{siuv} incorporates a centralised policy-based \gls{sts} that manages, authenticates and verifies identities, and exchanges them with contextualised privileges using \glspl{vc}.
\gls{siuv} also includes \acrshort{ucsp} nodes that protect localised vehicular resources using privileges issued by the \gls{sts} as well as continuous monitoring and policy re-evaluation.
The \gls{sts} and the architecture of \gls{siuv} are described in the next sections, and more details can be found in the corresponding paper in \cite{siuv}.

\subsubsection{\gls{siuv} \gls{sts}}
In a typical \gls{sts}, a particular set of privileges may be bound to specific attributes.
Thus, all subjects that have these attributes will always have the same privileges regardless of the context.
In addition, issued privileges do not change even if attributes change.
This usually results in subjects being either overprivileged or underprivileged.
To solve such issues, we introduced a session-based and policy-based \gls{sts} that exchanges external \glspl{vc} about identity claims (identity \glspl{vc}) with internal contextualised \glspl{vc} that determine the privileges of the corresponding subject.
The \gls{sts} shares the following common principles with \acrshort{ucsp}:
Policy-based decision making, which enables a dynamic exchange of identity claims with privileges according to situation-aware policies;
Session-based continuous monitoring, which allows the \gls{sts} to manage a continuous lifecylce of privileges starting from their issuance and lasting until their expiry or revocation, or even beyond revocation to support post-revocation interactions such as graceful revocation; and
Policy re-evaluation, which provides the \gls{sts} with the ability to react to changes in identity claims or environmental conditions resulting in privilege escalation, degradation or revocation.
The architecture of the \gls{sts} can be found in the paper in \cite{siuv}.

We use \gls{alfa} policies to determine how the \gls{sts} issues privileges according to identity claims and environmental attributes.
We particularly use rule obligations to determine the specific privileges that must be issued.
Thus, each rule is used to define a set of privileges to be issued if the conditions of the rule are met. 
This allows a fine-grained control on how to issue privileges according to attribute values.
We use the ``permitUnlessDeny'' combining algorithm, which combines all obligations from all applicable rules that evaluate into permit as long as no deny rule apply.
An example policy is shown in Listing \ref{lst:driver_sts_policy}.

\begin{lstlisting}[float=!tbh,caption={STS policy example},label={lst:driver_sts_policy}]
	policySet privileges {
		apply permitUnlessDeny
		policy driver {
			apply firstApplicable
			rule driver_dk_eu {
				target clause Attributes.license.expiry > time.now()
					and Attributes.license.issuer == ''borger.dk''
				condition Attributes.age > 18
					and Attributes.ucs.step == ''ongoing''
				permit
				on permit {
					obligation canDrive { command = ''issue_privileges''
						canDrive = true }
			}}
			rule revoke {
				deny
				on deny {
					obligation canDrive { command = ''revoke_privileges''
						canDrive = false }
		}}};
		policy wiperControl {  ...  };
	};
\end{lstlisting}

\subsubsection{\acrshort{siuv} Architecture}\label{sec:siuv_architecture}
The architecture of \acrshort{siuv} is shown in Figure \ref{fig:iam_architecutre} and described as follows.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{figures/siuv_architecture.png}
	\caption{\acrshort{siuv} architecture}
	\label{fig:iam_architecutre}
\end{figure}

\texttt{\glspl{idp}}
are authorities that issue identity \glspl{vc} about drivers, passengers or applications.

\texttt{A subject}
may be a driver, a passenger or an application that needs to access other resources, and is represented by a digital wallet that holds the subject's \glspl{vc}.
The digital wallet interacts with the issuers and the \gls{sts} to present/obtain \glspl{vc}, and with \acrshort{ucsp} nodes to request access to resources.

\texttt{The \gls{vdr}}
is a distributed hash table that holds revocation lists and issuers' public keys.
The \gls{vdr} may also be used to store other relevant information like metadata about proofs or schemas of \glspl{vc}.

\texttt{The \gls{sts}} is the core component that provides dynamic identity and privilege management of subjects.

\texttt{Localised \acrshort{ucsp} nodes} are used to protect resources such as domain controllers or \glspl{ecu}.
They make usage decisions based on the localised context and resource attributes as well as privileges issued by the \gls{sts}.
Thus, the \gls{sts} handles the global context of the whole vehicle, while localised \acrshort{ucsp} nodes manage localised authorisation contexts of individual components.

\subsubsection{GAIA-X \gls{iam}} \label{sec:gaiax}
The \gls{sts} introduced in \gls{siuv} can be adopted in GAIA-X as a baseline for a policy-based middleware that supports interoperability between identity technologies.
The middleware can also be used by GAIA-X participants as a service to delegate the issuance and verification of credentials.
The policy-based evaluation and the continuous monitoring allows the middleware to react to contextual and situational changes and to update the issued credentials accordingly.
This part of the research is currently in progress and results should be available soon.
We are studying the different identity technologies that must be supported in GAIA-X as well as the interoperability issues and the different verification mechanisms.

\subsection{State and Session Management in Clustered \acrshort{ucsp}}\label{sec:disrtibution}
In this section we introduce two architectures for clustering \acrshort{ucsp} nodes and we discuss the corresponding session management.
The objective is to allow a cluster of \acrshort{ucsp} nodes to work together and cooperate for handling a large number of usage sessions in cloud or enterprise environments.
\acrshort{ucsp} in this case would be provided as a microservice behind a \gls{gw} where the load of session management and policy evaluation is shared among multiple nodes.
The two architectures are designated as Stateful-Node Architecture and Stateless-Node Architecture and are described in the next subsections.
In both architectures, a \gls{pap} service is used to store and manage policies, and attribute retrievers are used to collect attribute values.
We also introduce three new components as follows:
\begin{itemize}
	\item \gls{srp}: A database that stores and persists information about all sessions within the cluster. It can be a centralised database or a distributed storage such as a \gls{dht}. This component is used to recreate sessions and resume them in case of failures.
	\item \gls{acp}: A cache of attribute values used to speed up the retrieval of attributes during policy evaluation. Like the \gls{srp}, the \gls{acp} can be a centralised or decentralised cache.
	\item \gls{pmp}: a component that keeps a mapping between attributes and usage sessions in order to invoke re-evaluations in the affected sessions when an attribute update occurs.
\end{itemize}
We are currently in the process of implementing the two architectures and evaluating them, so more details will be available soon.
This work is focused on cloud and enterprise environments, but we plan in future iterations to explore distribution and session management in \gls{iot} and \gls{iov} applications, where computing resources are limited and access to information (e.g., attributes) is challenging.

\subsubsection{Stateful-Node Architecture}
In this architecture, a cluster of \acrshort{ucsp} nodes handle different sessions.
Each node incorporates a \gls{pmp} and handles at least one session.
The full lifecycle of a single usage session is handled by one and only one node, so the nodes can be considered to be stateful.
\acrshort{ucsp} nodes update the \gls{srp} upon re-evaluations of sessions in order to persist all session data.
They also communicate with attribute retrievers to collect attribute values and cache them in the \gls{acp} as shown in Figure \ref{fig:stateful}.

Since sessions are associated with particular \acrshort{ucsp} nodes, a recovery mechanism must be employed to restore and resume sessions after a failure.
One possible solution is to introduce a health chck service that monitors \acrshort{ucsp} nodes and reassigns sessions to new nodes when a failure occurs.
During the time period between failure of a \acrshort{ucsp} node and the reassignment of its sessions, some attribute values may change.
Thus, when a session is reassigned to a new node, the node must re-evaluate the corresponding policies and update the session information in the \gls{srp}.
 
This architecture improves the performance of the overall lifecycle of the session since the session object is created only once and handled in memory in the node.
The architecture is also scalable because additional \acrshort{ucsp} nodes can be easily added to the cluster.
However, resources may be wasted in this architecture because \acrshort{ucsp} nodes are always kept active even if no re-evaluations are invoked.
Moreover, some sessions may use attributes that are updated frequently while other sessions remain idle for long periods of time.
Thus, load balancing is difficult in this architecture because we cannot know in advance which sessions will be active, so some \acrshort{ucsp} nodes may end up being busy while others remain idle.
Accordingly, this architecture is ideal for use-cases where all attributes change very frequently, because nodes will be fully utilised. 
In addition, sessions would already be loaded in \acrshort{ucsp} nodes so there is no overhead of loading sessions every time a re-evaluation is invoked.


\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{figures/stateful.png}
	\caption{Stateful-node architecture}
	\label{fig:stateful}
\end{figure}

\subsubsection{Stateless-Node Architecture}
The stateless-node architecture is shown in Figure \ref{fig:stateless} where a cluster of \glspl{pmp} monitor and keep track of all sessions.
On the other hand, \acrshort{ucsp} nodes handle evaluations only rather than handling full lifecycles of usage sessions.
Specifically, when a usage request is created or when an attribute is updated, a \gls{pmp} queues an evaluation job, and one \acrshort{ucsp} node picks the job, loads session information from the \gls{srp} then evaluates policies and updates the session information.
Therefore, the lifecycle of a usage session may be handled by multiple \acrshort{ucsp} nodes.

The \gls{pmp} cluster is vital in this architecture because it keeps track of all sessions within the system.
To allow scalability and avoid failures, \glspl{pmp} can act as backups for one another and each \gls{pmp} can track a subset of sessions only.
Thus, if a \gls{pmp} fails, its backup can keep monitoring the corresponding sessions until another \gls{pmp} is up.
Furthermore, when a \gls{pmp} queues an evaluation job, it can keep checking for a response, so that if the \acrshort{ucsp} node that picked the job fails before completing the evaluation, the \gls{pmp} can time out and assign the job to another \acrshort{ucsp} node.
This makes the cluster highly resilient as it can mitigate failures quickly and easily.
In addition, resource utilisation in this architecture is high as load can be properly distributed and balanced, because \acrshort{ucsp} nodes are invoked only when needed.
However, this architecture introduces a performance overhead of loading sessions from storage every time a re-evaluation is invoked.
Accordingly, this architecture is ideal for use-cases in which attributes do not change very frequently as this eliminates the overhead of loading sessions many times.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{figures/stateless.png}
	\caption{Stateless-node architecture}
	\label{fig:stateless}
\end{figure}